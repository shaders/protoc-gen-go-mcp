// Copyright 2025 Redpanda Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generator

import (
	"crypto/sha1"
	"encoding/json"
	"fmt"
	"go/token"
	"math/big"
	"path"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	GeneratedFilenameExtension = ".pb.mcp.go"
)

type FileGenerator struct {
	f   *protogen.File
	gen *protogen.Plugin

	gf *protogen.GeneratedFile

	// messageMap maps from protoreflect.MessageDescriptor to protogen.Message
	messageMap map[string]*protogen.Message
}

func NewFileGenerator(f *protogen.File, gen *protogen.Plugin) *FileGenerator {
	gen.SupportedFeatures |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

	fg := &FileGenerator{f: f, gen: gen}
	fg.buildMessageMap()
	return fg
}

// buildMessageMap creates a mapping from message full names to protogen.Message
func (g *FileGenerator) buildMessageMap() {
	g.messageMap = make(map[string]*protogen.Message)
	g.addMessagesToMap(g.f.Messages)
}

// addMessagesToMap recursively adds messages and nested messages to the map
func (g *FileGenerator) addMessagesToMap(messages []*protogen.Message) {
	for _, msg := range messages {
		g.messageMap[string(msg.Desc.FullName())] = msg
		// Recursively add nested messages
		g.addMessagesToMap(msg.Messages)
	}
}

// extractFieldComments extracts and cleans comments from protogen message fields
func (g *FileGenerator) extractFieldComments(protoMsg *protogen.Message) map[string]string {
	if protoMsg == nil {
		return nil
	}

	fieldComments := make(map[string]string, len(protoMsg.Fields))
	for _, field := range protoMsg.Fields {
		if comment := cleanComment(string(field.Comments.Leading)); comment != "" {
			fieldComments[string(field.Desc.Name())] = comment
		}
	}
	return fieldComments
}

// getMessageSchema generates schema for a message, checking well-known types first
func (g *FileGenerator) getMessageSchema(md protoreflect.MessageDescriptor) map[string]any {
	fullName := string(md.FullName())

	// Check for well-known types first
	if schema, ok := wellKnownTypeSchemas[fullName]; ok {
		return schema
	}

	// Try to find the protogen message for nested message comments
	if protoMsg, ok := g.messageMap[fullName]; ok {
		return g.messageSchemaWithComments(protoMsg)
	}

	return g.messageSchema(md)
}

// getEnumSchema generates schema for an enum
func (g *FileGenerator) getEnumSchema(ed protoreflect.EnumDescriptor) map[string]any {
	values := make([]string, 0, ed.Values().Len())
	for i := 0; i < ed.Values().Len(); i++ {
		values = append(values, string(ed.Values().Get(i).Name()))
	}
	return map[string]any{
		"type": "string",
		"enum": values,
	}
}

// buildAnyOfConstraints converts oneOf groups to anyOf constraints for OpenAPI compatibility
func (g *FileGenerator) buildAnyOfConstraints(oneOf map[string][]map[string]any) []map[string]any {
	anyOf := make([]map[string]any, 0, len(oneOf))
	for _, protoOneOf := range oneOf {
		anyOf = append(anyOf, map[string]any{
			"oneOf":    protoOneOf,
			"$comment": "In this schema, there is a oneOf group for every protobuf oneOf block in the message.",
		})
	}
	return anyOf
}

const fileTemplate = `// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: {{ .SourcePath }}

package {{ .GoPackage }}

import (
  "context"
  "strings"
  "github.com/mark3labs/mcp-go/mcp"
  mcpserver "github.com/mark3labs/mcp-go/server"
  "encoding/json"
  "google.golang.org/protobuf/encoding/protojson"
  grpc "google.golang.org/grpc"
  "github.com/shaders/protoc-gen-go-mcp/pkg/runtime"
  "google.golang.org/protobuf/proto"
  "google.golang.org/protobuf/reflect/protoreflect"
)

// Tool represents an MCP tool definition with essential fields
type Tool struct {
  Name        string
  Description string
  JSONSchema  string
}

var (
{{- range $key, $val := .Tools }}
  {{$key}}Tool = Tool{Name: {{ printf "%q" $val.Name }}, Description: {{ printf "%q" $val.Description }}, JSONSchema: {{ printf "%q" $val.JSONSchema }}}
{{- end }}
)



{{- range $serviceName, $methods := .Services }}
// {{$serviceName}}Client is compatible with the grpc-go client interface.
type {{$serviceName}}Client interface {
  {{- range $methodName, $tool := $methods }}
  {{$methodName}}(ctx context.Context, req *{{$tool.RequestType}}, opts ...grpc.CallOption) (*{{$tool.ResponseType}}, error)
  {{- end }}
}
{{ end }}



{{- range $serviceName, $methods := .Services }}
// TODO: BUG: https://github.com/anthropics/claude-code/issues/3084
// {{$serviceName}}NormalizeTopLevelJSONStringsForOneofs scans m's top level and, for keys that are members
// of any (or selected) oneof(s) in the given proto message type, it will parse string values
// that look like JSON and replace them with the parsed value.
// If oneofNames is empty, all oneofs are considered. Otherwise only the named oneofs are used.
func {{$serviceName}}NormalizeTopLevelJSONStringsForOneofs(
	m map[string]interface{},
	msg proto.Message,
	oneofNames ...string,
) (changed bool) {
	if m == nil || msg == nil {
		return false
	}

	md := msg.ProtoReflect().Descriptor()
	// Build a set of target oneof descriptors
	var targetOneofs map[protoreflect.OneofDescriptor]struct{}
	if len(oneofNames) > 0 {
		targetOneofs = map[protoreflect.OneofDescriptor]struct{}{}
	outer:
		for i := 0; i < md.Oneofs().Len(); i++ {
			od := md.Oneofs().Get(i)
			for _, name := range oneofNames {
				if string(od.Name()) == name {
					targetOneofs[od] = struct{}{}
					continue outer
				}
			}
		}
	}

	// Collect JSON names of fields that belong to the target oneof(s)
	jsonNames := map[string]struct{}{}
	for i := 0; i < md.Fields().Len(); i++ {
		fd := md.Fields().Get(i)
		if fd.ContainingOneof() == nil {
			continue
		}
		if targetOneofs != nil {
			if _, ok := targetOneofs[fd.ContainingOneof()]; !ok {
				continue
			}
		}
		// fd.JSONName() is the canonical JSON field name ("cat", "dog", ...)
		jsonNames[fd.JSONName()] = struct{}{}
		// Also consider the proto field name in case your map uses snake_case
		jsonNames[string(fd.Name())] = struct{}{}
	}

	// Rewrite top-level stringified JSON for those keys
	for k, v := range m {
		if _, ok := jsonNames[k]; !ok {
			continue
		}
		s, ok := v.(string)
		if !ok {
			continue
		}
		trim := strings.TrimSpace(s)
		if trim == "" || !(strings.HasPrefix(trim, "{") || strings.HasPrefix(trim, "[")) {
			continue
		}
		var parsed any
		if err := json.Unmarshal([]byte(trim), &parsed); err != nil {
			continue // ignore if it's not valid JSON
		}
		m[k] = parsed
		changed = true
	}
	return changed
}
{{- end }}


{{- range $key, $val := .Services }}
// ForwardTo{{$key}}Client registers a gRPC client, to forward MCP calls to it.
func ForwardTo{{$key}}Client(s *mcpserver.MCPServer, client {{$key}}Client, opts ...runtime.Option) {
  config := runtime.NewConfig()
  for _, opt := range opts {
    opt(config)
  }

  {{- range $tool_name, $tool_val := $val }}
  {{$tool_name}}ToolDef := {{$key | capitalizeFirst}}_{{$tool_name}}Tool

  // Convert simple Tool to mcp.Tool
  {{$tool_name}}Tool := mcp.Tool{
    Name:        {{$tool_name}}ToolDef.Name,
    Description: {{$tool_name}}ToolDef.Description,
    RawInputSchema: json.RawMessage({{$tool_name}}ToolDef.JSONSchema),
  }

  // Add extra properties to schema if configured
  if len(config.ExtraProperties) > 0 {
    {{$tool_name}}Tool = runtime.AddExtraPropertiesToTool({{$tool_name}}Tool, config.ExtraProperties)
  }

  s.AddTool({{$tool_name}}Tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    var req {{$tool_val.RequestType}}

    message := request.GetArguments()

    // Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
    _ = {{$key}}NormalizeTopLevelJSONStringsForOneofs(message, &req, "kind")

    // Extract extra properties if configured
    for _, prop := range config.ExtraProperties {
      if propVal, ok := message[prop.Name]; ok {
        ctx = context.WithValue(ctx, prop.ContextKey, propVal)
      }
    }

    marshaled, err := json.Marshal(message)
    if err != nil {
      return nil, err
    }

    if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
      return nil, err
    }

    resp, err := client.{{$tool_name}}(ctx, &req)
    if err != nil {
      return runtime.HandleError(err)
    }

    marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
    if err != nil {
      return nil, err
    }
    return mcp.NewToolResultText(string(marshaled)), nil
  })
  {{- end }}
}
{{- end }}


`

type TplParams struct {
	PackageName string
	SourcePath  string
	GoPackage   string
	Tools       map[string]SimpleTool
	Services    map[string]map[string]MethodInfo
}

// SimpleTool represents the generated tool definition
type SimpleTool struct {
	Name        string
	Description string
	JSONSchema  string
}

// MethodInfo holds information about a service method
type MethodInfo struct {
	RequestType  string
	ResponseType string
}

func kindToType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.BoolKind:
		return "boolean"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
		protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "integer"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
		protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "string" // safely encode as string
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return "number"
	case protoreflect.BytesKind:
		return "string"
	case protoreflect.EnumKind:
		return "string" // optionally add enum values here
	default:
		return "string"
	}
}

func isFieldRequired(fd protoreflect.FieldDescriptor) bool {
	if proto.HasExtension(fd.Options(), annotations.E_FieldBehavior) {
		behaviors := proto.GetExtension(fd.Options(), annotations.E_FieldBehavior).([]annotations.FieldBehavior)
		for _, behavior := range behaviors {
			if behavior == annotations.FieldBehavior_REQUIRED {
				return true
			}
		}
	}
	return false
}

// messageSchemaWithComments generates a schema for a protogen.Message with comments
func (g *FileGenerator) messageSchemaWithComments(msg *protogen.Message) map[string]any {
	return g.messageSchemaFromDescriptor(msg.Desc, msg)
}

// messageSchema generates a schema for a protoreflect.MessageDescriptor without comments
func (g *FileGenerator) messageSchema(md protoreflect.MessageDescriptor) map[string]any {
	return g.messageSchemaFromDescriptor(md, nil)
}

func (g *FileGenerator) messageSchemaFromDescriptor(md protoreflect.MessageDescriptor, protoMsg *protogen.Message) map[string]any {
	required := []string{}
	// Fields that are not oneOf
	normalFields := map[string]any{}
	// One entry per oneOf block in the message.
	oneOf := map[string][]map[string]any{}

	// Create a map of field names to comments for lookup
	fieldComments := g.extractFieldComments(protoMsg)

	// Process all fields in the message descriptor
	for i := 0; i < md.Fields().Len(); i++ {
		nestedFd := md.Fields().Get(i)
		name := string(nestedFd.Name())

		// Get field comment if available
		var comment string
		if fieldComments != nil {
			comment = fieldComments[name]
		}

		// OneOf handling
		if oneof := nestedFd.ContainingOneof(); oneof != nil && !oneof.IsSynthetic() {
			if _, ok := oneOf[string(oneof.Name())]; !ok {
				oneOf[string(oneof.Name())] = []map[string]any{}
			}
			oneOf[string(oneof.Name())] = append(oneOf[string(oneof.Name())], map[string]any{
				"properties": map[string]any{
					name: g.getTypeWithComment(nestedFd, comment),
				},
				"required": []string{name},
			})
		} else {
			// If not part of a oneof, handle as a normal field
			normalFields[name] = g.getTypeWithComment(nestedFd, comment)
			if isFieldRequired(nestedFd) {
				required = append(required, name)
			}
		}
	}

	// Build final schema
	result := map[string]any{
		"type":       "object",
		"properties": normalFields,
		"required":   required,
	}

	// Add oneOf constraints if any exist
	if len(oneOf) > 0 {
		result["anyOf"] = g.buildAnyOfConstraints(oneOf)
	}

	return result
}

// getTypeWithComment generates a schema for a field with an optional comment
func (g *FileGenerator) getTypeWithComment(fd protoreflect.FieldDescriptor, comment string) map[string]any {
	schema := g.getType(fd)

	// Add description if comment is available and not empty
	if trimmed := strings.TrimSpace(comment); trimmed != "" {
		schema["description"] = trimmed
	}

	return schema
}

func (g *FileGenerator) getType(fd protoreflect.FieldDescriptor) map[string]any {
	if fd.IsMap() {
		keyType := fd.MapKey().Kind()
		keyConstraints := map[string]any{"type": "string"}

		switch keyType {
		case protoreflect.BoolKind:
			keyConstraints["enum"] = []string{"true", "false"}
		case protoreflect.Uint32Kind, protoreflect.Fixed32Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
			keyConstraints["pattern"] = "^(0|[1-9]\\d*)$"
		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind, protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
			keyConstraints["pattern"] = "^-?(0|[1-9]\\d*)$"
		}

		return map[string]any{
			"type":                 "object",
			"propertyNames":        keyConstraints,
			"additionalProperties": g.getType(fd.MapValue()),
		}
	}

	var schema map[string]any

	switch fd.Kind() {
	case protoreflect.MessageKind:
		schema = g.getMessageSchema(fd.Message())

	case protoreflect.EnumKind:
		schema = g.getEnumSchema(fd.Enum())

	default:
		schema = map[string]any{
			"type": kindToType(fd.Kind()),
		}
		if fd.Kind() == protoreflect.BytesKind {
			schema["contentEncoding"] = "base64"
			schema["format"] = "byte"
		}
	}

	// Handle repeated fields here, wrapping the actual schema in an array.
	if fd.IsList() {
		return map[string]any{
			"type":  "array",
			"items": schema,
		}
	}
	return schema
}

var (
	strippedCommentPrefixes = []string{"buf:lint:", "@ignore-comment"}

	// wellKnownTypeSchemas defines schemas for well-known protobuf types
	wellKnownTypeSchemas = map[string]map[string]any{
		"google.protobuf.Timestamp": {"type": []string{"string", "null"}, "format": "date-time"},
		"google.protobuf.Duration":  {"type": []string{"string", "null"}, "pattern": `^-?[0-9]+(\.[0-9]+)?s$`},
		"google.protobuf.Struct": {
			"type":                 "object",
			"additionalProperties": true,
		},
		"google.protobuf.Value": {
			"description": "represents a google.protobuf.Value, a dynamic JSON value (string, number, boolean, array, object).",
		},
		"google.protobuf.ListValue": {
			"type":        "array",
			"description": "represents a google.protobuf.ListValue, a JSON array of values.",
			"items":       map[string]any{},
		},
		"google.protobuf.FieldMask": {"type": "string"},
		"google.protobuf.Any": {
			"type": []string{"object", "null"},
			"properties": map[string]any{
				"@type": map[string]any{"type": "string"},
				"value": map[string]any{},
			},
			"required": []string{"@type"},
		},
		"google.protobuf.DoubleValue": {"type": "number", "nullable": true},
		"google.protobuf.FloatValue":  {"type": "number", "nullable": true},
		"google.protobuf.Int32Value":  {"type": "number", "nullable": true},
		"google.protobuf.UInt32Value": {"type": "number", "nullable": true},
		"google.protobuf.Int64Value":  {"type": "string", "nullable": true},
		"google.protobuf.UInt64Value": {"type": "string", "nullable": true},
		"google.protobuf.StringValue": {"type": "string", "nullable": true},
		"google.protobuf.BoolValue":   {"type": "boolean", "nullable": true},
		"google.protobuf.BytesValue":  {"type": "string", "format": "byte", "nullable": true},
	}
)

func cleanComment(comment string) string {
	var cleanedLines []string
outer:
	for _, line := range strings.Split(comment, "\n") {
		trimmed := strings.TrimSpace(line)
		for _, strip := range strippedCommentPrefixes {
			if strings.HasPrefix(trimmed, strip) {
				continue outer
			}
		}
		cleanedLines = append(cleanedLines, trimmed)
	}
	return strings.Join(cleanedLines, "\n")
}

func Base32String(b []byte) string {
	n := new(big.Int).SetBytes(b)
	return n.Text(36)
}

func MangleHeadIfTooLong(name string, maxLen int) string {
	if len(name) <= maxLen {
		// Just sanitize the original name if it's short enough
		return sanitizeForGemini(name)
	}

	// Generate short hash of full name
	hash := sha1.Sum([]byte(name))
	hashPrefix := Base32String(hash[:])[:6] // e.g. "3fj92a"

	// Leave room for hash prefix + underscore
	available := maxLen - len(hashPrefix) - 1
	if available <= 0 {
		return sanitizeForGemini(hashPrefix)
	}

	// Preserve the end of the name (most specific)
	tail := name[len(name)-available:]
	result := hashPrefix + "_" + tail

	// Sanitize the final result once
	return sanitizeForGemini(result)
}

// sanitizeForGemini ensures the name complies with Gemini tool name restrictions:
// - Must start with a letter or underscore
// - Only alphanumeric, underscores, dots, colons, or dashes allowed
// - Maximum length of 64 characters
func sanitizeForGemini(name string) string {
	if len(name) == 0 {
		return "tool"
	}

	var result strings.Builder
	result.Grow(minInt(len(name), 64))

	for _, r := range name {
		switch {
		case isLetter(r), isDigit(r):
			result.WriteRune(r)
		case r == '_' || r == '.' || r == ':' || r == '-':
			result.WriteRune(r)
		case r == '/' || r == ' ':
			// Convert common separators to underscores
			result.WriteRune('_')
		default:
			// Skip invalid characters
		}

		// Stop at 64 characters
		if result.Len() >= 64 {
			break
		}
	}

	finalName := result.String()

	// Ensure it starts with letter or underscore
	if len(finalName) == 0 {
		return "tool"
	}

	finalName = ensureValidStart(finalName)

	// Trim to max length
	if len(finalName) > 64 {
		finalName = finalName[:64]
	}

	return finalName
}

// ensureValidStart ensures the string starts with a letter or underscore as required by Gemini
func ensureValidStart(s string) string {
	if len(s) == 0 {
		return "tool"
	}
	if !isLetter(rune(s[0])) && s[0] != '_' {
		if len(s) == 1 {
			return "t_" + s
		}
		return "t" + s[1:] // Replace first char with 't'
	}
	return s
}

func isLetter(r rune) bool {
	return (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z')
}

func isDigit(r rune) bool {
	return r >= '0' && r <= '9'
}

func minInt(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func capitalizeFirstLetter(s string) string {
	i := 0
	for i < len(s) {
		r, size := utf8.DecodeRuneInString(s[i:])
		if !unicode.IsLetter(r) {
			i += size
			continue
		}
		ur := unicode.ToUpper(r)
		if ur == r {
			return s
		}
		var b strings.Builder
		b.Grow(len(s))
		b.WriteString(s[:i])
		b.WriteRune(ur)
		b.WriteString(s[i+size:])
		return b.String()
	}
	return s
}

func (g *FileGenerator) Generate(packageSuffix string) {
	file := g.f
	if len(g.f.Services) == 0 {
		return
	}
	goImportPath := file.GoImportPath
	if packageSuffix != "" {
		if !token.IsIdentifier(packageSuffix) {
			g.gen.Error(fmt.Errorf("package_suffix %q is not a valid Go identifier", packageSuffix))
			return
		}
		file.GoPackageName += protogen.GoPackageName(packageSuffix)
		generatedFilenamePrefixToSlash := filepath.ToSlash(file.GeneratedFilenamePrefix)
		file.GeneratedFilenamePrefix = path.Join(
			path.Dir(generatedFilenamePrefixToSlash),
			string(file.GoPackageName),
			path.Base(generatedFilenamePrefixToSlash),
		)
		goImportPath = protogen.GoImportPath(path.Join(
			string(file.GoImportPath),
			string(file.GoPackageName),
		))
	}

	g.gf = g.gen.NewGeneratedFile(
		file.GeneratedFilenamePrefix+GeneratedFilenameExtension,
		goImportPath,
	)
	if packageSuffix != "" {
		g.gf.Import(file.GoImportPath)
	}

	funcMap := template.FuncMap{
		"capitalizeFirst": capitalizeFirstLetter,
	}

	fileTpl := fileTemplate
	tpl, err := template.New("gen").Funcs(funcMap).Parse(fileTpl)
	if err != nil {
		g.gen.Error(err)
		return
	}

	services := map[string]map[string]MethodInfo{}
	tools := map[string]SimpleTool{}

	for _, svc := range g.f.Services {
		s := map[string]MethodInfo{}
		for _, meth := range svc.Methods {
			// Only unary supported at the moment
			if meth.Desc.IsStreamingClient() || meth.Desc.IsStreamingServer() {
				continue
			}

			// Generate schema with comments
			schema := g.messageSchemaWithComments(meth.Input)
			marshaled, err := json.Marshal(schema)
			if err != nil {
				panic(err)
			}

			// Create simple tool
			tool := SimpleTool{
				Name:        MangleHeadIfTooLong(strings.ReplaceAll(string(meth.Desc.FullName()), ".", "_"), 64),
				Description: cleanComment(string(meth.Comments.Leading)),
				JSONSchema:  string(marshaled),
			}

			s[meth.GoName] = MethodInfo{
				RequestType:  g.gf.QualifiedGoIdent(meth.Input.GoIdent),
				ResponseType: g.gf.QualifiedGoIdent(meth.Output.GoIdent),
			}

			tools[svc.GoName+"_"+meth.GoName] = tool
		}
		services[string(svc.Desc.Name())] = s
	}

	params := TplParams{
		PackageName: string(g.f.Desc.Package()),
		SourcePath:  g.f.Desc.Path(),
		GoPackage:   string(g.f.GoPackageName),
		Services:    services,
		Tools:       tools,
	}
	err = tpl.Execute(g.gf, params)
	if err != nil {
		g.gen.Error(err)
	}
}
