// Copyright 2025 Redpanda Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generator

import (
	"crypto/sha1"
	"encoding/json"
	"fmt"
	"go/token"
	"math/big"
	"path"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	// GeneratedFilenameExtension is the extension for generated MCP files
	GeneratedFilenameExtension = ".pb.mcp.go"

	// MaxToolNameLength is the maximum length for tool names (Gemini restriction)
	MaxToolNameLength = 64

	// HashPrefixLength is the length of the hash prefix for mangled names
	HashPrefixLength = 6
)

// FileGenerator handles protobuf to MCP schema generation for a single file
type FileGenerator struct {
	f   *protogen.File
	gen *protogen.Plugin

	gf *protogen.GeneratedFile

	// messageMap maps from protoreflect.MessageDescriptor to protogen.Message
	// for efficient lookup of protogen messages from descriptors
	messageMap map[string]*protogen.Message

	// optionalKeywordSupport when true makes fields required by default unless marked optional
	optionalKeywordSupport bool
}

// NewFileGenerator creates a new FileGenerator for the given protobuf file
func NewFileGenerator(f *protogen.File, gen *protogen.Plugin) *FileGenerator {
	gen.SupportedFeatures |= uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

	fg := &FileGenerator{f: f, gen: gen}
	fg.buildMessageMap()
	return fg
}

// buildMessageMap creates a mapping from message full names to protogen.Message
func (g *FileGenerator) buildMessageMap() {
	g.messageMap = make(map[string]*protogen.Message)
	g.addMessagesToMap(g.f.Messages)
}

// addMessagesToMap recursively adds messages and nested messages to the map
func (g *FileGenerator) addMessagesToMap(messages []*protogen.Message) {
	for _, msg := range messages {
		g.messageMap[string(msg.Desc.FullName())] = msg
		// Recursively add nested messages
		g.addMessagesToMap(msg.Messages)
	}
}

// extractFieldComments extracts and cleans comments from protogen message fields
func (g *FileGenerator) extractFieldComments(protoMsg *protogen.Message) map[string]string {
	if protoMsg == nil {
		return nil
	}

	fieldComments := make(map[string]string, len(protoMsg.Fields))
	for _, field := range protoMsg.Fields {
		if comment := cleanComment(string(field.Comments.Leading)); comment != "" {
			fieldComments[string(field.Desc.Name())] = comment
		}
	}
	return fieldComments
}

// getMessageSchema generates schema for a message, checking well-known types first
func (g *FileGenerator) getMessageSchema(md protoreflect.MessageDescriptor) map[string]any {
	fullName := string(md.FullName())

	// Check for well-known types first
	if schema, ok := wellKnownTypeSchemas[fullName]; ok {
		return schema
	}

	// Try to find the protogen message for nested message comments
	if protoMsg, ok := g.messageMap[fullName]; ok {
		return g.messageSchemaWithComments(protoMsg)
	}

	return g.messageSchema(md)
}

// getEnumSchema generates schema for an enum
func (g *FileGenerator) getEnumSchema(ed protoreflect.EnumDescriptor) map[string]any {
	values := make([]string, 0, ed.Values().Len())
	for i := 0; i < ed.Values().Len(); i++ {
		values = append(values, string(ed.Values().Get(i).Name()))
	}
	return map[string]any{
		"type": "string",
		"enum": values,
	}
}

// addOneOfConstraints adds simplified oneOf fields to the schema properties and marks them as required
func (g *FileGenerator) addOneOfConstraints(normalFields map[string]any, oneOf map[string][]map[string]any, required []string) []string {
	// For each oneOf group, add a oneOf field to properties
	for oneOfName, variants := range oneOf {
		// Add "OneOfType" postfix to the field name
		fieldName := oneOfName + "OneOfType"
		normalFields[fieldName] = map[string]any{
			"oneOf": variants,
		}
		// OneOf fields are mandatory in protobuf, so add to required array
		required = append(required, fieldName)
	}
	return required
}

const fileTemplate = `// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: {{ .SourcePath }}

package {{ .GoPackage }}

import (
  "context"
  "strings"
  "github.com/mark3labs/mcp-go/mcp"
  mcpserver "github.com/mark3labs/mcp-go/server"
  "encoding/json"
  "google.golang.org/protobuf/encoding/protojson"
  grpc "google.golang.org/grpc"
  "github.com/shaders/protoc-gen-go-mcp/pkg/runtime"
  "google.golang.org/protobuf/proto"
  "google.golang.org/protobuf/reflect/protoreflect"
)

var (
{{- range $key, $val := .Tools }}
  {{$key}}Tool = runtime.Tool{Name: {{ printf "%q" $val.Name }}, Description: {{ printf "%q" $val.Description }}, JSONSchema: {{ printf "%q" $val.JSONSchema }}}
{{- end }}
)



{{- range $serviceName, $methods := .Services }}
// {{$serviceName}}Client is compatible with the grpc-go client interface.
type {{$serviceName}}Client interface {
  {{- range $methodName, $tool := $methods }}
  {{$methodName}}(ctx context.Context, req *{{$tool.RequestType}}, opts ...grpc.CallOption) (*{{$tool.ResponseType}}, error)
  {{- end }}
}
{{ end }}



{{- range $serviceName, $methods := .Services }}
// TODO: BUG: https://github.com/anthropics/claude-code/issues/3084
// {{$serviceName}}NormalizeTopLevelJSONStringsForOneofs scans m's top level and, for keys that are members
// of any (or selected) oneof(s) in the given proto message type, it will parse string values
// that look like JSON and replace them with the parsed value.
// If oneofNames is empty, all oneofs are considered. Otherwise only the named oneofs are used.
func {{$serviceName}}NormalizeTopLevelJSONStringsForOneofs(
	m map[string]interface{},
	msg proto.Message,
	oneofNames ...string,
) (changed bool) {
	if m == nil || msg == nil {
		return false
	}

	md := msg.ProtoReflect().Descriptor()
	// Build a set of target oneof descriptors
	var targetOneofs map[protoreflect.OneofDescriptor]struct{}
	if len(oneofNames) > 0 {
		targetOneofs = map[protoreflect.OneofDescriptor]struct{}{}
	outer:
		for i := 0; i < md.Oneofs().Len(); i++ {
			od := md.Oneofs().Get(i)
			for _, name := range oneofNames {
				if string(od.Name()) == name {
					targetOneofs[od] = struct{}{}
					continue outer
				}
			}
		}
	}

	// Collect JSON names of fields that belong to the target oneof(s)
	jsonNames := map[string]struct{}{}
	for i := 0; i < md.Fields().Len(); i++ {
		fd := md.Fields().Get(i)
		if fd.ContainingOneof() == nil {
			continue
		}
		if targetOneofs != nil {
			if _, ok := targetOneofs[fd.ContainingOneof()]; !ok {
				continue
			}
		}
		// fd.JSONName() is the canonical JSON field name ("cat", "dog", ...)
		jsonNames[fd.JSONName()] = struct{}{}
		// Also consider the proto field name in case your map uses snake_case
		jsonNames[string(fd.Name())] = struct{}{}
	}

	// Rewrite top-level stringified JSON for those keys
	for k, v := range m {
		if _, ok := jsonNames[k]; !ok {
			continue
		}
		s, ok := v.(string)
		if !ok {
			continue
		}
		trim := strings.TrimSpace(s)
		if trim == "" || !(strings.HasPrefix(trim, "{") || strings.HasPrefix(trim, "[")) {
			continue
		}
		var parsed any
		if err := json.Unmarshal([]byte(trim), &parsed); err != nil {
			continue // ignore if it's not valid JSON
		}
		m[k] = parsed
		changed = true
	}
	return changed
}

// {{$serviceName}}TransformOneOfFields transforms discriminated union fields back to protobuf oneOf format
func {{$serviceName}}TransformOneOfFields(m map[string]interface{}) {
	{{$serviceName}}TransformOneOfFieldsRecursive(m)
}

// {{$serviceName}}TransformOneOfFieldsRecursive recursively transforms oneOf fields in nested objects
func {{$serviceName}}TransformOneOfFieldsRecursive(obj interface{}) {
	switch v := obj.(type) {
	case map[string]interface{}:
		// Transform oneOf fields in this object
		for key, value := range v {
			// Check if this looks like a oneOf discriminated union (must have OneOfType postfix)
			if strings.HasSuffix(key, "OneOfType") {
				if unionObj, ok := value.(map[string]interface{}); ok {
					if typeField, hasType := unionObj["object_type"]; hasType {
						if typeStr, ok := typeField.(string); ok {
							// Create a new object without the object_type field
							variantObj := make(map[string]interface{})
							for k, val := range unionObj {
								if k != "object_type" {
									variantObj[k] = val
								}
							}

							// Replace the union object with the variant object
							v[typeStr] = variantObj
							delete(v, key)
						}
					}
				}
			}
		}

		// Recursively process all values
		for _, value := range v {
			{{$serviceName}}TransformOneOfFieldsRecursive(value)
		}
	case []interface{}:
		// Process array elements
		for _, item := range v {
			{{$serviceName}}TransformOneOfFieldsRecursive(item)
		}
	}
}
{{- end }}


{{- range $key, $val := .Services }}
// ForwardTo{{$key}}Client registers a gRPC client, to forward MCP calls to it.
func ForwardTo{{$key}}Client(s *mcpserver.MCPServer, client {{$key}}Client, opts ...runtime.Option) {
  config := runtime.NewConfig()
  for _, opt := range opts {
    opt(config)
  }

  {{- range $tool_name, $tool_val := $val }}
  {{$tool_name}}ToolDef := {{$key | capitalizeFirst}}_{{$tool_name}}Tool

  // Convert simple Tool to mcp.Tool
  {{$tool_name}}Tool := mcp.Tool{
    Name:        {{$tool_name}}ToolDef.Name,
    Description: {{$tool_name}}ToolDef.Description,
    RawInputSchema: json.RawMessage({{$tool_name}}ToolDef.JSONSchema),
  }

  // Add extra properties to schema if configured
  if len(config.ExtraProperties) > 0 {
    {{$tool_name}}Tool = runtime.AddExtraPropertiesToTool({{$tool_name}}Tool, config.ExtraProperties)
  }

  s.AddTool({{$tool_name}}Tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    var req {{$tool_val.RequestType}}

    message := request.GetArguments()

    // Transform oneOf discriminated unions back to protobuf format
    {{$key}}TransformOneOfFields(message)

    // Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
	// TODO: checking that the bug was fixed
    // _ = {{$key}}NormalizeTopLevelJSONStringsForOneofs(message, &req, "")

    // Extract extra properties if configured
    for _, prop := range config.ExtraProperties {
      if propVal, ok := message[prop.Name]; ok {
        ctx = context.WithValue(ctx, prop.ContextKey, propVal)
      }
    }

    marshaled, err := json.Marshal(message)
    if err != nil {
      return nil, err
    }

    if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
      return nil, err
    }

    resp, err := client.{{$tool_name}}(ctx, &req)
    if err != nil {
      return runtime.HandleError(err)
    }

    marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
    if err != nil {
      return nil, err
    }
    return mcp.NewToolResultText(string(marshaled)), nil
  })
  {{- end }}
}
{{- end }}


`

type TplParams struct {
	PackageName string
	SourcePath  string
	GoPackage   string
	Tools       map[string]SimpleTool
	Services    map[string]map[string]MethodInfo
}

// SimpleTool represents the generated tool definition
type SimpleTool struct {
	Name        string
	Description string
	JSONSchema  string
}

// MethodInfo holds information about a service method
type MethodInfo struct {
	RequestType  string
	ResponseType string
}

func kindToType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.BoolKind:
		return "boolean"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind,
		protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "integer"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind,
		protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "integer"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return "number"
	case protoreflect.BytesKind:
		return "string"
	case protoreflect.EnumKind:
		return "string" // optionally add enum values here
	default:
		return "string"
	}
}

func isFieldRequired(fd protoreflect.FieldDescriptor) bool {
	if proto.HasExtension(fd.Options(), annotations.E_FieldBehavior) {
		behaviors := proto.GetExtension(fd.Options(), annotations.E_FieldBehavior).([]annotations.FieldBehavior)
		for _, behavior := range behaviors {
			if behavior == annotations.FieldBehavior_REQUIRED {
				return true
			}
		}
	}
	return false
}

// isFieldRequiredWithOptionalSupport checks if a field is required considering optional keyword support
func (g *FileGenerator) isFieldRequiredWithOptionalSupport(fd protoreflect.FieldDescriptor) bool {
	// Repeated fields are never required (they can be empty arrays)
	if fd.IsList() {
		return false
	}

	// Map fields are never required (they can be empty objects)
	if fd.IsMap() {
		return false
	}

	// First check google.api.field_behavior annotation
	if isFieldRequired(fd) {
		return true
	}

	// If optional keyword support is enabled
	if g.optionalKeywordSupport {
		// Check if field is marked as optional (proto3 optional or part of synthetic oneof)
		if fd.HasOptionalKeyword() {
			return false
		}
		// In optional keyword support mode, fields are required by default unless marked optional
		return true
	}

	// Default behavior: fields are not required unless explicitly marked
	return false
}

// messageSchemaWithComments generates a schema for a protogen.Message with comments
func (g *FileGenerator) messageSchemaWithComments(msg *protogen.Message) map[string]any {
	return g.messageSchemaFromDescriptor(msg.Desc, msg)
}

// messageSchema generates a schema for a protoreflect.MessageDescriptor without comments
func (g *FileGenerator) messageSchema(md protoreflect.MessageDescriptor) map[string]any {
	return g.messageSchemaFromDescriptor(md, nil)
}

func (g *FileGenerator) messageSchemaFromDescriptor(md protoreflect.MessageDescriptor, protoMsg *protogen.Message) map[string]any {
	required := make([]string, 0)
	// Fields that are not oneOf
	normalFields := make(map[string]any)
	// One entry per oneOf block in the message.
	oneOf := make(map[string][]map[string]any)

	// Create a map of field names to comments for lookup
	fieldComments := g.extractFieldComments(protoMsg)

	// Process all fields in the message descriptor
	for i := 0; i < md.Fields().Len(); i++ {
		nestedFd := md.Fields().Get(i)
		name := string(nestedFd.Name())

		// Get field comment if available
		var comment string
		if fieldComments != nil {
			comment = fieldComments[name]
		}

		// OneOf handling - collect oneOf fields for later processing
		if oneof := nestedFd.ContainingOneof(); oneof != nil && !oneof.IsSynthetic() {
			oneOfName := string(oneof.Name())
			g.processOneOfField(nestedFd, comment, name, oneOfName, oneOf,
				func(fd protoreflect.FieldDescriptor, c string) map[string]any {
					return g.getTypeWithComment(fd, c)
				})
		} else {
			// If not part of a oneof, handle as a normal field
			normalFields[name] = g.getTypeWithComment(nestedFd, comment)
			if g.isFieldRequiredWithOptionalSupport(nestedFd) {
				required = append(required, name)
			}
		}
	}

	// Add oneOf constraints if any exist
	if len(oneOf) > 0 {
		required = g.addOneOfConstraints(normalFields, oneOf, required)
	}

	// Build final schema
	result := map[string]any{
		"type":       "object",
		"properties": normalFields,
		"required":   required,
	}

	return result
}

// messageSchemaWithDefs generates a top-level schema with $defs for nested message types
func (g *FileGenerator) messageSchemaWithDefs(md protoreflect.MessageDescriptor, protoMsg *protogen.Message) map[string]any {
	defs := make(map[string]any)
	visiting := make(map[string]bool) // Track types being processed to prevent cycles
	required := make([]string, 0)
	// Fields that are not oneOf
	normalFields := make(map[string]any)
	// One entry per oneOf block in the message.
	oneOf := make(map[string][]map[string]any)

	// Create a map of field names to comments for lookup
	fieldComments := g.extractFieldComments(protoMsg)

	// Process all fields in the message descriptor
	for i := 0; i < md.Fields().Len(); i++ {
		nestedFd := md.Fields().Get(i)
		name := string(nestedFd.Name())

		// Get field comment if available
		var comment string
		if fieldComments != nil {
			comment = fieldComments[name]
		}

		// OneOf handling - collect oneOf fields for later processing
		if oneof := nestedFd.ContainingOneof(); oneof != nil && !oneof.IsSynthetic() {
			oneOfName := string(oneof.Name())
			g.processOneOfField(nestedFd, comment, name, oneOfName, oneOf,
				func(fd protoreflect.FieldDescriptor, c string) map[string]any {
					return g.getTypeWithDefsAndComment(fd, c, defs, visiting)
				})
		} else {
			// If not part of a oneof, handle as a normal field
			normalFields[name] = g.getTypeWithDefsAndComment(nestedFd, comment, defs, visiting)
			if g.isFieldRequiredWithOptionalSupport(nestedFd) {
				required = append(required, name)
			}
		}
	}

	// Add oneOf constraints if any exist
	if len(oneOf) > 0 {
		required = g.addOneOfConstraints(normalFields, oneOf, required)
	}

	// Build final schema
	result := map[string]any{
		"$schema":    "https://json-schema.org/draft/2020-12/schema",
		"type":       "object",
		"properties": normalFields,
		"required":   required,
	}

	// Add $defs if any were collected
	if len(defs) > 0 {
		result["$defs"] = defs
	}

	return result
}

// messageSchemaWithDefsInternal generates schema with cycle detection support
func (g *FileGenerator) messageSchemaWithDefsInternal(md protoreflect.MessageDescriptor, protoMsg *protogen.Message, defs map[string]any, visiting map[string]bool) map[string]any {
	required := make([]string, 0)
	normalFields := make(map[string]any)
	oneOf := make(map[string][]map[string]any)

	fieldComments := g.extractFieldComments(protoMsg)

	for i := 0; i < md.Fields().Len(); i++ {
		nestedFd := md.Fields().Get(i)
		name := string(nestedFd.Name())

		var comment string
		if fieldComments != nil {
			comment = fieldComments[name]
		}

		if oneof := nestedFd.ContainingOneof(); oneof != nil && !oneof.IsSynthetic() {
			oneOfName := string(oneof.Name())
			g.processOneOfField(nestedFd, comment, name, oneOfName, oneOf,
				func(fd protoreflect.FieldDescriptor, c string) map[string]any {
					return g.getTypeWithDefsAndComment(fd, c, defs, visiting)
				})
		} else {
			normalFields[name] = g.getTypeWithDefsAndComment(nestedFd, comment, defs, visiting)
			if g.isFieldRequiredWithOptionalSupport(nestedFd) {
				required = append(required, name)
			}
		}
	}

	if len(oneOf) > 0 {
		required = g.addOneOfConstraints(normalFields, oneOf, required)
	}

	result := map[string]any{
		"type":       "object",
		"properties": normalFields,
		"required":   required,
	}

	return result
}

// messageSchemaFromDescriptorWithDefs generates schema for nested messages with cycle detection
func (g *FileGenerator) messageSchemaFromDescriptorWithDefs(md protoreflect.MessageDescriptor, protoMsg *protogen.Message, defs map[string]any, visiting map[string]bool) map[string]any {
	return g.messageSchemaWithDefsInternal(md, protoMsg, defs, visiting)
}

// processOneOfField handles the creation of oneOf schema variants with proper type assertions
func (g *FileGenerator) processOneOfField(
	nestedFd protoreflect.FieldDescriptor,
	comment string,
	name string,
	oneOfName string,
	oneOf map[string][]map[string]any,
	getSchemaFunc func(protoreflect.FieldDescriptor, string) map[string]any,
) {
	if _, ok := oneOf[oneOfName]; !ok {
		oneOf[oneOfName] = []map[string]any{}
	}

	// Create a discriminated union entry
	fieldSchema := getSchemaFunc(nestedFd, comment)

	// Check if the field schema is a $ref (for message types)
	if _, isRef := fieldSchema["$ref"]; isRef {
		// For message types, create properties with the field and object_type
		props := map[string]any{
			name: fieldSchema, // Include the field with its $ref
			"object_type": map[string]any{
				"type":  "string",
				"const": name,
			},
		}

		variant := map[string]any{
			"type":       "object",
			"title":      name,
			"properties": props,
			"required":   []string{"object_type", name},
		}

		oneOf[oneOfName] = append(oneOf[oneOfName], variant)
	} else {
		// For non-message types, handle properties normally
		if fieldSchema["properties"] == nil {
			fieldSchema["properties"] = map[string]any{}
		}
		props, ok := fieldSchema["properties"].(map[string]any)
		if !ok {
			props = map[string]any{}
			fieldSchema["properties"] = props
		}

		props["object_type"] = map[string]any{
			"type":  "string",
			"const": name,
		}

		variant := map[string]any{
			"type":       "object",
			"title":      name,
			"properties": props,
			"required":   []string{"object_type"},
		}

		// Add other required fields from the original schema
		if originalRequired, ok := fieldSchema["required"]; ok {
			if reqArray, ok := originalRequired.([]string); ok && len(reqArray) > 0 {
				variant["required"] = append([]string{"object_type"}, reqArray...)
			}
		}

		oneOf[oneOfName] = append(oneOf[oneOfName], variant)
	}
}

// getTypeWithComment generates a schema for a field with an optional comment
func (g *FileGenerator) getTypeWithComment(fd protoreflect.FieldDescriptor, comment string) map[string]any {
	schema := g.getType(fd)

	// Add description if comment is available and not empty
	if trimmed := strings.TrimSpace(comment); trimmed != "" {
		schema["description"] = trimmed
	}

	return schema
}

// getTypeWithDefsAndComment generates a schema for a field with $defs collection
func (g *FileGenerator) getTypeWithDefsAndComment(fd protoreflect.FieldDescriptor, comment string, defs map[string]any, visiting map[string]bool) map[string]any {
	schema := g.getTypeWithDefs(fd, defs, visiting)

	// Add description if comment is available and not empty
	if trimmed := strings.TrimSpace(comment); trimmed != "" {
		schema["description"] = trimmed
	}

	return schema
}

func (g *FileGenerator) getType(fd protoreflect.FieldDescriptor) map[string]any {
	if fd.IsMap() {
		keyType := fd.MapKey().Kind()
		keyConstraints := map[string]any{"type": "string"}

		switch keyType {
		case protoreflect.BoolKind:
			keyConstraints["enum"] = []string{"true", "false"}
		case protoreflect.Uint32Kind, protoreflect.Fixed32Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
			keyConstraints["pattern"] = "^(0|[1-9]\\d*)$"
		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind, protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
			keyConstraints["pattern"] = "^-?(0|[1-9]\\d*)$"
		}

		return map[string]any{
			"type":          "object",
			"propertyNames": keyConstraints,
		}
	}

	var schema map[string]any

	switch fd.Kind() {
	case protoreflect.MessageKind:
		schema = g.getMessageSchema(fd.Message())

	case protoreflect.EnumKind:
		schema = g.getEnumSchema(fd.Enum())

	default:
		schema = map[string]any{
			"type": kindToType(fd.Kind()),
		}
		if fd.Kind() == protoreflect.BytesKind {
			schema["contentEncoding"] = "base64"
			schema["format"] = "byte"
		}
	}

	// Handle repeated fields here, wrapping the actual schema in an array.
	if fd.IsList() {
		return map[string]any{
			"type":  "array",
			"items": schema,
		}
	}
	return schema
}

// getTypeWithDefs generates a schema for a field, using $ref for message types
func (g *FileGenerator) getTypeWithDefs(fd protoreflect.FieldDescriptor, defs map[string]any, visiting map[string]bool) map[string]any {
	if fd.IsMap() {
		keyType := fd.MapKey().Kind()
		keyConstraints := map[string]any{"type": "string"}

		switch keyType {
		case protoreflect.BoolKind:
			keyConstraints["enum"] = []string{"true", "false"}
		case protoreflect.Uint32Kind, protoreflect.Fixed32Kind, protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
			keyConstraints["pattern"] = "^(0|[1-9]\\d*)$"
		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind, protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
			keyConstraints["pattern"] = "^-?(0|[1-9]\\d*)$"
		}

		return map[string]any{
			"type":          "object",
			"propertyNames": keyConstraints,
		}
	}

	var schema map[string]any

	switch fd.Kind() {
	case protoreflect.MessageKind:
		md := fd.Message()
		fullName := string(md.FullName())

		// Check if this is a well-known type
		if wktSchema, ok := wellKnownTypeSchemas[fullName]; ok {
			schema = wktSchema
		} else {
			// Use simple name for the definition key
			defName := string(md.Name())

			// Check if we're currently processing this type (cycle detection)
			if visiting[fullName] {
				// We're in a recursive reference, just use $ref without adding to defs
				schema = map[string]any{
					"$ref": "#/$defs/" + defName,
				}
			} else if _, exists := defs[defName]; !exists {
				// Mark as visiting to detect cycles
				visiting[fullName] = true

				// Generate the full schema for this message
				if protoMsg, ok := g.messageMap[fullName]; ok {
					defs[defName] = g.messageSchemaFromDescriptorWithDefs(md, protoMsg, defs, visiting)
				} else {
					defs[defName] = g.messageSchemaWithDefsInternal(md, nil, defs, visiting)
				}

				// Unmark after processing
				delete(visiting, fullName)

				// Return a $ref to the definition
				schema = map[string]any{
					"$ref": "#/$defs/" + defName,
				}
			} else {
				// Already exists in defs, just reference it
				schema = map[string]any{
					"$ref": "#/$defs/" + defName,
				}
			}
		}

	case protoreflect.EnumKind:
		schema = g.getEnumSchema(fd.Enum())

	default:
		schema = map[string]any{
			"type": kindToType(fd.Kind()),
		}
		if fd.Kind() == protoreflect.BytesKind {
			schema["contentEncoding"] = "base64"
			schema["format"] = "byte"
		}
	}

	// Handle repeated fields here, wrapping the actual schema in an array.
	if fd.IsList() {
		return map[string]any{
			"type":  "array",
			"items": schema,
		}
	}
	return schema
}

var (
	strippedCommentPrefixes = []string{"buf:lint:", "@ignore-comment"}

	// wellKnownTypeSchemas defines schemas for well-known protobuf types
	wellKnownTypeSchemas = map[string]map[string]any{
		"google.protobuf.Timestamp": {"type": []string{"string", "null"}, "format": "date-time"},
		"google.protobuf.Duration":  {"type": []string{"string", "null"}, "pattern": `^-?[0-9]+(\.[0-9]+)?s$`},
		"google.protobuf.Struct": {
			"type": "object",
		},
		"google.protobuf.Value": {
			"description": "represents a google.protobuf.Value, a dynamic JSON value (string, number, boolean, array, object).",
		},
		"google.protobuf.ListValue": {
			"type":        "array",
			"description": "represents a google.protobuf.ListValue, a JSON array of values.",
			"items":       map[string]any{},
		},
		"google.protobuf.FieldMask": {"type": "string"},
		"google.protobuf.Any": {
			"type": []string{"object", "null"},
			"properties": map[string]any{
				"@type": map[string]any{"type": "string"},
				"value": map[string]any{},
			},
			"required": []string{"@type"},
		},
		"google.protobuf.DoubleValue": {"type": "number", "nullable": true},
		"google.protobuf.FloatValue":  {"type": "number", "nullable": true},
		"google.protobuf.Int32Value":  {"type": "integer", "nullable": true},
		"google.protobuf.UInt32Value": {"type": "integer", "nullable": true},
		"google.protobuf.Int64Value":  {"type": "integer", "nullable": true},
		"google.protobuf.UInt64Value": {"type": "integer", "nullable": true},
		"google.protobuf.StringValue": {"type": "string", "nullable": true},
		"google.protobuf.BoolValue":   {"type": "boolean", "nullable": true},
		"google.protobuf.BytesValue":  {"type": "string", "format": "byte", "nullable": true},
	}
)

func cleanComment(comment string) string {
	var cleanedLines []string
outer:
	for _, line := range strings.Split(comment, "\n") {
		trimmed := strings.TrimSpace(line)
		for _, strip := range strippedCommentPrefixes {
			if strings.HasPrefix(trimmed, strip) {
				continue outer
			}
		}
		cleanedLines = append(cleanedLines, trimmed)
	}
	return strings.Join(cleanedLines, "\n")
}

// Base32String converts bytes to base32 string representation
func Base32String(b []byte) string {
	n := new(big.Int).SetBytes(b)
	return n.Text(36)
}

// MangleHeadIfTooLong truncates and mangles long names to fit within maxLen
// while preserving uniqueness through a hash prefix
func MangleHeadIfTooLong(name string, maxLen int) string {
	if len(name) <= maxLen {
		// Just sanitize the original name if it's short enough
		return sanitizeForGemini(name)
	}

	// Generate short hash of full name
	hash := sha1.Sum([]byte(name))
	hashPrefix := Base32String(hash[:])[:HashPrefixLength] // e.g. "3fj92a"

	// Leave room for hash prefix + underscore
	available := maxLen - len(hashPrefix) - 1
	if available <= 0 {
		return sanitizeForGemini(hashPrefix)
	}

	// Preserve the end of the name (most specific)
	tail := name[len(name)-available:]
	result := hashPrefix + "_" + tail

	// Sanitize the final result once
	return sanitizeForGemini(result)
}

// sanitizeForGemini ensures the name complies with Gemini tool name restrictions:
// - Must start with a letter or underscore
// - Only alphanumeric, underscores, dots, colons, or dashes allowed
// - Maximum length of MaxToolNameLength characters
func sanitizeForGemini(name string) string {
	if len(name) == 0 {
		return "tool"
	}

	var result strings.Builder
	result.Grow(minInt(len(name), MaxToolNameLength))

	for _, r := range name {
		switch {
		case isLetter(r), isDigit(r):
			result.WriteRune(r)
		case r == '_' || r == '.' || r == ':' || r == '-':
			result.WriteRune(r)
		case r == '/' || r == ' ':
			// Convert common separators to underscores
			result.WriteRune('_')
		default:
			// Skip invalid characters
		}

		// Stop at MaxToolNameLength characters
		if result.Len() >= MaxToolNameLength {
			break
		}
	}

	finalName := result.String()

	// Ensure it starts with letter or underscore
	if len(finalName) == 0 {
		return "tool"
	}

	finalName = ensureValidStart(finalName)

	// Trim to max length
	if len(finalName) > MaxToolNameLength {
		finalName = finalName[:MaxToolNameLength]
	}

	return finalName
}

// ensureValidStart ensures the string starts with a letter or underscore as required by Gemini
func ensureValidStart(s string) string {
	if len(s) == 0 {
		return "tool"
	}
	if !isLetter(rune(s[0])) && s[0] != '_' {
		if len(s) == 1 {
			return "t_" + s
		}
		return "t" + s[1:] // Replace first char with 't'
	}
	return s
}

func isLetter(r rune) bool {
	return (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z')
}

func isDigit(r rune) bool {
	return r >= '0' && r <= '9'
}

func minInt(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func capitalizeFirstLetter(s string) string {
	i := 0
	for i < len(s) {
		r, size := utf8.DecodeRuneInString(s[i:])
		if !unicode.IsLetter(r) {
			i += size
			continue
		}
		ur := unicode.ToUpper(r)
		if ur == r {
			return s
		}
		var b strings.Builder
		b.Grow(len(s))
		b.WriteString(s[:i])
		b.WriteRune(ur)
		b.WriteString(s[i+size:])
		return b.String()
	}
	return s
}

// Generate generates MCP server code for the protobuf file
func (g *FileGenerator) Generate(packageSuffix string) {
	g.GenerateWithOptions(packageSuffix, false)
}

// GenerateWithOptions generates MCP server code with additional options
func (g *FileGenerator) GenerateWithOptions(packageSuffix string, optionalKeywordSupport bool) {
	g.optionalKeywordSupport = optionalKeywordSupport
	file := g.f
	if len(g.f.Services) == 0 {
		return
	}
	goImportPath := file.GoImportPath
	if packageSuffix != "" {
		if !token.IsIdentifier(packageSuffix) {
			g.gen.Error(fmt.Errorf("package_suffix %q is not a valid Go identifier", packageSuffix))
			return
		}
		file.GoPackageName += protogen.GoPackageName(packageSuffix)
		generatedFilenamePrefixToSlash := filepath.ToSlash(file.GeneratedFilenamePrefix)
		file.GeneratedFilenamePrefix = path.Join(
			path.Dir(generatedFilenamePrefixToSlash),
			string(file.GoPackageName),
			path.Base(generatedFilenamePrefixToSlash),
		)
		goImportPath = protogen.GoImportPath(path.Join(
			string(file.GoImportPath),
			string(file.GoPackageName),
		))
	}

	g.gf = g.gen.NewGeneratedFile(
		file.GeneratedFilenamePrefix+GeneratedFilenameExtension,
		goImportPath,
	)
	if packageSuffix != "" {
		g.gf.Import(file.GoImportPath)
	}

	funcMap := template.FuncMap{
		"capitalizeFirst": capitalizeFirstLetter,
	}

	fileTpl := fileTemplate
	tpl, err := template.New("gen").Funcs(funcMap).Parse(fileTpl)
	if err != nil {
		g.gen.Error(err)
		return
	}

	services := map[string]map[string]MethodInfo{}
	tools := map[string]SimpleTool{}

	for _, svc := range g.f.Services {
		s := map[string]MethodInfo{}
		for _, meth := range svc.Methods {
			// Only unary supported at the moment
			if meth.Desc.IsStreamingClient() || meth.Desc.IsStreamingServer() {
				continue
			}

			// Generate schema with $defs for nested messages
			schema := g.messageSchemaWithDefs(meth.Input.Desc, meth.Input)
			marshaled, err := json.Marshal(schema)
			if err != nil {
				g.gen.Error(fmt.Errorf("failed to marshal JSON schema for %s: %w", meth.Desc.FullName(), err))
				continue
			}

			// Create simple tool
			tool := SimpleTool{
				Name:        MangleHeadIfTooLong(strings.ReplaceAll(string(meth.Desc.FullName()), ".", "_"), MaxToolNameLength),
				Description: cleanComment(string(meth.Comments.Leading)),
				JSONSchema:  string(marshaled),
			}

			s[meth.GoName] = MethodInfo{
				RequestType:  g.gf.QualifiedGoIdent(meth.Input.GoIdent),
				ResponseType: g.gf.QualifiedGoIdent(meth.Output.GoIdent),
			}

			tools[svc.GoName+"_"+meth.GoName] = tool
		}
		services[string(svc.Desc.Name())] = s
	}

	params := TplParams{
		PackageName: string(g.f.Desc.Package()),
		SourcePath:  g.f.Desc.Path(),
		GoPackage:   string(g.f.GoPackageName),
		Services:    services,
		Tools:       tools,
	}
	err = tpl.Execute(g.gf, params)
	if err != nil {
		g.gen.Error(err)
	}
}
