// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: google/bytestream/bytestream.proto

package bytestreammcp

import (
	bytestream "google.golang.org/genproto/googleapis/bytestream"
)

import (
	"context"
	"encoding/json"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"github.com/shaders/protoc-gen-go-mcp/pkg/runtime"
	grpc "google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"
	"strings"
)

var (
	ByteStream_QueryWriteStatusTool = runtime.Tool{Name: "google_bytestream_ByteStream_QueryWriteStatus", Description: "`QueryWriteStatus()` is used to find the `committed_size` for a resource\nthat is being written, which can then be used as the `write_offset` for\nthe next `Write()` call.\n\nIf the resource does not exist (i.e., the resource has been deleted, or the\nfirst `Write()` has not yet reached the service), this method returns the\nerror `NOT_FOUND`.\n\nThe client **may** call `QueryWriteStatus()` at any time to determine how\nmuch data has been processed for this resource. This is useful if the\nclient is buffering data and needs to know which data can be safely\nevicted. For any sequence of `QueryWriteStatus()` calls for a given\nresource name, the sequence of returned `committed_size` values will be\nnon-decreasing.\n", JSONSchema: "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"properties\":{\"resource_name\":{\"description\":\"The name of the resource whose write status is being requested.\",\"type\":\"string\"}},\"required\":[],\"type\":\"object\"}"}
)

// ByteStreamClient is compatible with the grpc-go client interface.
type ByteStreamClient interface {
	QueryWriteStatus(ctx context.Context, req *bytestream.QueryWriteStatusRequest, opts ...grpc.CallOption) (*bytestream.QueryWriteStatusResponse, error)
}

// ByteStreamNormalizeTopLevelJSONStringsForOneofs scans m's top level and, for keys that end with
// "OneOfType" (as defined in the tool's JSON schema), it will parse string values that look like JSON
// and replace them with the parsed value.
func ByteStreamNormalizeTopLevelJSONStringsForOneofs(
	m map[string]interface{},
	toolSchema string,
) (changed bool) {
	if m == nil || toolSchema == "" {
		return false
	}

	// Parse the tool schema to find OneOfType fields
	var schema map[string]interface{}
	if err := json.Unmarshal([]byte(toolSchema), &schema); err != nil {
		return false
	}

	// Extract properties from the schema
	properties, ok := schema["properties"].(map[string]interface{})
	if !ok {
		return false
	}

	// Find all fields ending with "OneOfType"
	oneOfTypeFields := map[string]struct{}{}
	for fieldName := range properties {
		if strings.HasSuffix(fieldName, "OneOfType") {
			oneOfTypeFields[fieldName] = struct{}{}
		}
	}

	// Rewrite top-level stringified JSON for OneOfType fields
	for k, v := range m {
		if _, ok := oneOfTypeFields[k]; !ok {
			continue
		}
		s, ok := v.(string)
		if !ok {
			continue
		}
		trim := strings.TrimSpace(s)
		if trim == "" || !(strings.HasPrefix(trim, "{") || strings.HasPrefix(trim, "[")) {
			continue
		}
		var parsed any
		if err := json.Unmarshal([]byte(trim), &parsed); err != nil {
			continue // ignore if it's not valid JSON
		}
		m[k] = parsed
		changed = true
	}
	return changed
}

// ByteStreamTransformOneOfFields transforms discriminated union fields back to protobuf oneOf format
func ByteStreamTransformOneOfFields(m map[string]interface{}) {
	ByteStreamTransformOneOfFieldsRecursive(m)
}

// ByteStreamTransformOneOfFieldsRecursive recursively transforms oneOf fields in nested objects
func ByteStreamTransformOneOfFieldsRecursive(obj interface{}) {
	switch v := obj.(type) {
	case map[string]interface{}:
		// Transform oneOf fields in this object
		for key, value := range v {
			// Check if this looks like a oneOf discriminated union (must have OneOfType postfix)
			if strings.HasSuffix(key, "OneOfType") {
				if unionObj, ok := value.(map[string]interface{}); ok {
					if typeField, hasType := unionObj["object_type"]; hasType {
						if typeStr, ok := typeField.(string); ok {
							// First try to extract the field that matches the object_type
							// (for message types with $ref)
							if fieldValue, hasField := unionObj[typeStr]; hasField {
								// Move the field value directly to the parent level
								v[typeStr] = fieldValue
								delete(v, key)
							} else {
								// Fall back to old logic: create object without object_type field
								// (for primitive types or inline objects)
								variantObj := make(map[string]interface{})
								for k, val := range unionObj {
									if k != "object_type" {
										variantObj[k] = val
									}
								}
								// Replace the union object with the variant object
								v[typeStr] = variantObj
								delete(v, key)
							}
						}
					}
				}
			}
		}

		// Recursively process all values
		for _, value := range v {
			ByteStreamTransformOneOfFieldsRecursive(value)
		}
	case []interface{}:
		// Process array elements
		for _, item := range v {
			ByteStreamTransformOneOfFieldsRecursive(item)
		}
	}
}

// ForwardToByteStreamClient registers a gRPC client, to forward MCP calls to it.
func ForwardToByteStreamClient(s *mcpserver.MCPServer, client ByteStreamClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	QueryWriteStatusToolDef := ByteStream_QueryWriteStatusTool

	// Convert simple Tool to mcp.Tool
	QueryWriteStatusTool := mcp.Tool{
		Name:           QueryWriteStatusToolDef.Name,
		Description:    QueryWriteStatusToolDef.Description,
		RawInputSchema: json.RawMessage(QueryWriteStatusToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		QueryWriteStatusTool = runtime.AddExtraPropertiesToTool(QueryWriteStatusTool, config.ExtraProperties)
	}

	s.AddTool(QueryWriteStatusTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req bytestream.QueryWriteStatusRequest

		message := request.GetArguments()

		// Fix oneof's passed as JSON string.
		_ = ByteStreamNormalizeTopLevelJSONStringsForOneofs(message, QueryWriteStatusToolDef.JSONSchema)

		// Transform oneOf discriminated unions back to protobuf format
		ByteStreamTransformOneOfFields(message)

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.QueryWriteStatus(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
