// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: google/longrunning/operations.proto

package longrunningpbmcp

import (
	longrunningpb "cloud.google.com/go/longrunning/autogen/longrunningpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

import (
	"context"
	"encoding/json"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"github.com/shaders/protoc-gen-go-mcp/pkg/runtime"
	grpc "google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"strings"
)

var (
	Operations_CancelOperationTool = runtime.Tool{Name: "google_longrunning_Operations_CancelOperation", Description: "Starts asynchronous cancellation on a long-running operation.  The server\nmakes a best effort to cancel the operation, but success is not\nguaranteed.  If the server doesn't support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.  Clients can use\n[Operations.GetOperation][google.longrunning.Operations.GetOperation] or\nother methods to check whether the cancellation succeeded or whether the\noperation completed despite cancellation. On successful cancellation,\nthe operation is not deleted; instead, it becomes an operation with\nan [Operation.error][google.longrunning.Operation.error] value with a\n[google.rpc.Status.code][google.rpc.Status.code] of `1`, corresponding to\n`Code.CANCELLED`.\n", JSONSchema: "{\"additionalProperties\":false,\"properties\":{\"name\":{\"description\":\"The name of the operation resource to be cancelled.\",\"type\":\"string\"}},\"required\":[],\"type\":\"object\"}"}
	Operations_DeleteOperationTool = runtime.Tool{Name: "google_longrunning_Operations_DeleteOperation", Description: "Deletes a long-running operation. This method indicates that the client is\nno longer interested in the operation result. It does not cancel the\noperation. If the server doesn't support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.\n", JSONSchema: "{\"additionalProperties\":false,\"properties\":{\"name\":{\"description\":\"The name of the operation resource to be deleted.\",\"type\":\"string\"}},\"required\":[],\"type\":\"object\"}"}
	Operations_GetOperationTool    = runtime.Tool{Name: "google_longrunning_Operations_GetOperation", Description: "Gets the latest state of a long-running operation.  Clients can use this\nmethod to poll the operation result at intervals as recommended by the API\nservice.\n", JSONSchema: "{\"additionalProperties\":false,\"properties\":{\"name\":{\"description\":\"The name of the operation resource.\",\"type\":\"string\"}},\"required\":[],\"type\":\"object\"}"}
	Operations_ListOperationsTool  = runtime.Tool{Name: "google_longrunning_Operations_ListOperations", Description: "Lists operations that match the specified filter in the request. If the\nserver doesn't support this method, it returns `UNIMPLEMENTED`.\n", JSONSchema: "{\"additionalProperties\":false,\"properties\":{\"filter\":{\"description\":\"The standard list filter.\",\"type\":\"string\"},\"name\":{\"description\":\"The name of the operation's parent resource.\",\"type\":\"string\"},\"page_size\":{\"description\":\"The standard list page size.\",\"type\":\"integer\"},\"page_token\":{\"description\":\"The standard list page token.\",\"type\":\"string\"}},\"required\":[],\"type\":\"object\"}"}
	Operations_WaitOperationTool   = runtime.Tool{Name: "google_longrunning_Operations_WaitOperation", Description: "Waits until the specified long-running operation is done or reaches at most\na specified timeout, returning the latest state.  If the operation is\nalready done, the latest state is immediately returned.  If the timeout\nspecified is greater than the default HTTP/RPC timeout, the HTTP/RPC\ntimeout is used.  If the server does not support this method, it returns\n`google.rpc.Code.UNIMPLEMENTED`.\nNote that this method is on a best-effort basis.  It may return the latest\nstate before the specified timeout (including immediately), meaning even an\nimmediate response is no guarantee that the operation is done.\n", JSONSchema: "{\"additionalProperties\":false,\"properties\":{\"name\":{\"description\":\"The name of the operation resource to wait on.\",\"type\":\"string\"},\"timeout\":{\"description\":\"The maximum duration to wait before timing out. If left blank, the wait\\nwill be at most the time permitted by the underlying HTTP/RPC protocol.\\nIf RPC context deadline is also specified, the shorter one will be used.\",\"pattern\":\"^-?[0-9]+(\\\\.[0-9]+)?s$\",\"type\":[\"string\",\"null\"]}},\"required\":[],\"type\":\"object\"}"}
)

// OperationsClient is compatible with the grpc-go client interface.
type OperationsClient interface {
	CancelOperation(ctx context.Context, req *longrunningpb.CancelOperationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteOperation(ctx context.Context, req *longrunningpb.DeleteOperationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetOperation(ctx context.Context, req *longrunningpb.GetOperationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	ListOperations(ctx context.Context, req *longrunningpb.ListOperationsRequest, opts ...grpc.CallOption) (*longrunningpb.ListOperationsResponse, error)
	WaitOperation(ctx context.Context, req *longrunningpb.WaitOperationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
}

// TODO: BUG: https://github.com/anthropics/claude-code/issues/3084
// OperationsNormalizeTopLevelJSONStringsForOneofs scans m's top level and, for keys that are members
// of any (or selected) oneof(s) in the given proto message type, it will parse string values
// that look like JSON and replace them with the parsed value.
// If oneofNames is empty, all oneofs are considered. Otherwise only the named oneofs are used.
func OperationsNormalizeTopLevelJSONStringsForOneofs(
	m map[string]interface{},
	msg proto.Message,
	oneofNames ...string,
) (changed bool) {
	if m == nil || msg == nil {
		return false
	}

	md := msg.ProtoReflect().Descriptor()
	// Build a set of target oneof descriptors
	var targetOneofs map[protoreflect.OneofDescriptor]struct{}
	if len(oneofNames) > 0 {
		targetOneofs = map[protoreflect.OneofDescriptor]struct{}{}
	outer:
		for i := 0; i < md.Oneofs().Len(); i++ {
			od := md.Oneofs().Get(i)
			for _, name := range oneofNames {
				if string(od.Name()) == name {
					targetOneofs[od] = struct{}{}
					continue outer
				}
			}
		}
	}

	// Collect JSON names of fields that belong to the target oneof(s)
	jsonNames := map[string]struct{}{}
	for i := 0; i < md.Fields().Len(); i++ {
		fd := md.Fields().Get(i)
		if fd.ContainingOneof() == nil {
			continue
		}
		if targetOneofs != nil {
			if _, ok := targetOneofs[fd.ContainingOneof()]; !ok {
				continue
			}
		}
		// fd.JSONName() is the canonical JSON field name ("cat", "dog", ...)
		jsonNames[fd.JSONName()] = struct{}{}
		// Also consider the proto field name in case your map uses snake_case
		jsonNames[string(fd.Name())] = struct{}{}
	}

	// Rewrite top-level stringified JSON for those keys
	for k, v := range m {
		if _, ok := jsonNames[k]; !ok {
			continue
		}
		s, ok := v.(string)
		if !ok {
			continue
		}
		trim := strings.TrimSpace(s)
		if trim == "" || !(strings.HasPrefix(trim, "{") || strings.HasPrefix(trim, "[")) {
			continue
		}
		var parsed any
		if err := json.Unmarshal([]byte(trim), &parsed); err != nil {
			continue // ignore if it's not valid JSON
		}
		m[k] = parsed
		changed = true
	}
	return changed
}

// OperationsTransformOneOfFields transforms discriminated union fields back to protobuf oneOf format
func OperationsTransformOneOfFields(m map[string]interface{}) {
	OperationsTransformOneOfFieldsRecursive(m)
}

// OperationsTransformOneOfFieldsRecursive recursively transforms oneOf fields in nested objects
func OperationsTransformOneOfFieldsRecursive(obj interface{}) {
	switch v := obj.(type) {
	case map[string]interface{}:
		// Transform oneOf fields in this object
		for key, value := range v {
			// Check if this looks like a oneOf discriminated union (must have OneOfType postfix)
			if strings.HasSuffix(key, "OneOfType") {
				if unionObj, ok := value.(map[string]interface{}); ok {
					if typeField, hasType := unionObj["object_type"]; hasType {
						if typeStr, ok := typeField.(string); ok {
							// Create a new object without the object_type field
							variantObj := make(map[string]interface{})
							for k, val := range unionObj {
								if k != "object_type" {
									variantObj[k] = val
								}
							}

							// Replace the union object with the variant object
							v[typeStr] = variantObj
							delete(v, key)
						}
					}
				}
			}
		}

		// Recursively process all values
		for _, value := range v {
			OperationsTransformOneOfFieldsRecursive(value)
		}
	case []interface{}:
		// Process array elements
		for _, item := range v {
			OperationsTransformOneOfFieldsRecursive(item)
		}
	}
}

// ForwardToOperationsClient registers a gRPC client, to forward MCP calls to it.
func ForwardToOperationsClient(s *mcpserver.MCPServer, client OperationsClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	CancelOperationToolDef := Operations_CancelOperationTool

	// Convert simple Tool to mcp.Tool
	CancelOperationTool := mcp.Tool{
		Name:           CancelOperationToolDef.Name,
		Description:    CancelOperationToolDef.Description,
		RawInputSchema: json.RawMessage(CancelOperationToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		CancelOperationTool = runtime.AddExtraPropertiesToTool(CancelOperationTool, config.ExtraProperties)
	}

	s.AddTool(CancelOperationTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req longrunningpb.CancelOperationRequest

		message := request.GetArguments()

		// Transform oneOf discriminated unions back to protobuf format
		OperationsTransformOneOfFields(message)

		// Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
		// TODO: checking that the bug was fixed
		// _ = OperationsNormalizeTopLevelJSONStringsForOneofs(message, &req, "")

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.CancelOperation(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	DeleteOperationToolDef := Operations_DeleteOperationTool

	// Convert simple Tool to mcp.Tool
	DeleteOperationTool := mcp.Tool{
		Name:           DeleteOperationToolDef.Name,
		Description:    DeleteOperationToolDef.Description,
		RawInputSchema: json.RawMessage(DeleteOperationToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		DeleteOperationTool = runtime.AddExtraPropertiesToTool(DeleteOperationTool, config.ExtraProperties)
	}

	s.AddTool(DeleteOperationTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req longrunningpb.DeleteOperationRequest

		message := request.GetArguments()

		// Transform oneOf discriminated unions back to protobuf format
		OperationsTransformOneOfFields(message)

		// Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
		// TODO: checking that the bug was fixed
		// _ = OperationsNormalizeTopLevelJSONStringsForOneofs(message, &req, "")

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.DeleteOperation(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	GetOperationToolDef := Operations_GetOperationTool

	// Convert simple Tool to mcp.Tool
	GetOperationTool := mcp.Tool{
		Name:           GetOperationToolDef.Name,
		Description:    GetOperationToolDef.Description,
		RawInputSchema: json.RawMessage(GetOperationToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		GetOperationTool = runtime.AddExtraPropertiesToTool(GetOperationTool, config.ExtraProperties)
	}

	s.AddTool(GetOperationTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req longrunningpb.GetOperationRequest

		message := request.GetArguments()

		// Transform oneOf discriminated unions back to protobuf format
		OperationsTransformOneOfFields(message)

		// Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
		// TODO: checking that the bug was fixed
		// _ = OperationsNormalizeTopLevelJSONStringsForOneofs(message, &req, "")

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetOperation(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	ListOperationsToolDef := Operations_ListOperationsTool

	// Convert simple Tool to mcp.Tool
	ListOperationsTool := mcp.Tool{
		Name:           ListOperationsToolDef.Name,
		Description:    ListOperationsToolDef.Description,
		RawInputSchema: json.RawMessage(ListOperationsToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		ListOperationsTool = runtime.AddExtraPropertiesToTool(ListOperationsTool, config.ExtraProperties)
	}

	s.AddTool(ListOperationsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req longrunningpb.ListOperationsRequest

		message := request.GetArguments()

		// Transform oneOf discriminated unions back to protobuf format
		OperationsTransformOneOfFields(message)

		// Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
		// TODO: checking that the bug was fixed
		// _ = OperationsNormalizeTopLevelJSONStringsForOneofs(message, &req, "")

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListOperations(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	WaitOperationToolDef := Operations_WaitOperationTool

	// Convert simple Tool to mcp.Tool
	WaitOperationTool := mcp.Tool{
		Name:           WaitOperationToolDef.Name,
		Description:    WaitOperationToolDef.Description,
		RawInputSchema: json.RawMessage(WaitOperationToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		WaitOperationTool = runtime.AddExtraPropertiesToTool(WaitOperationTool, config.ExtraProperties)
	}

	s.AddTool(WaitOperationTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req longrunningpb.WaitOperationRequest

		message := request.GetArguments()

		// Transform oneOf discriminated unions back to protobuf format
		OperationsTransformOneOfFields(message)

		// Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
		// TODO: checking that the bug was fixed
		// _ = OperationsNormalizeTopLevelJSONStringsForOneofs(message, &req, "")

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.WaitOperation(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
