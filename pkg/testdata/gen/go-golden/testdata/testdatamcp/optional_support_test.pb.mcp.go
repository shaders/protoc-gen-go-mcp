// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: testdata/optional_support_test.proto

package testdatamcp

import (
	testdata "github.com/shaders/protoc-gen-go-mcp/pkg/testdata/gen/go-golden/testdata"
)

import (
	"context"
	"strings"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"encoding/json"
	"google.golang.org/protobuf/encoding/protojson"
	grpc "google.golang.org/grpc"
	"github.com/shaders/protoc-gen-go-mcp/pkg/runtime"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	OptionalSupportTestService_TestOptionalFieldsTool = runtime.Tool{Name: "testdata_OptionalSupportTestService_TestOptionalFields", Description: "Test method with various field types to test optional keyword support\n", JSONSchema: "{\"properties\":{\"annotated_required_field\":{\"description\":\"Field marked as required via annotation - should always be required\",\"type\":\"string\"},\"map_field\":{\"description\":\"Map field (should never be required as it can be empty)\",\"propertyNames\":{\"type\":\"string\"},\"type\":\"object\"},\"optional_annotated_field\":{\"description\":\"Optional field with annotation - annotation takes precedence\",\"type\":\"string\"},\"optional_bool\":{\"description\":\"Optional bool field\",\"type\":\"boolean\"},\"optional_field\":{\"description\":\"Optional field - should not be required regardless of setting\",\"type\":\"string\"},\"optional_number\":{\"description\":\"Optional int32 field\",\"type\":\"integer\"},\"regular_bool\":{\"description\":\"Regular bool field\",\"type\":\"boolean\"},\"regular_field\":{\"description\":\"Regular field - should be required when optional keyword support is enabled\",\"type\":\"string\"},\"regular_number\":{\"description\":\"Regular int32 field\",\"type\":\"integer\"},\"repeated_field\":{\"description\":\"Repeated field (should never be required as it can be empty)\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"annotated_required_field\",\"optional_annotated_field\"],\"type\":\"object\"}"}
)

// OptionalSupportTestServiceClient is compatible with the grpc-go client interface.
type OptionalSupportTestServiceClient interface {
	TestOptionalFields(ctx context.Context, req *testdata.TestOptionalFieldsRequest, opts ...grpc.CallOption) (*testdata.TestOptionalFieldsResponse, error)
}

// TODO: BUG: https://github.com/anthropics/claude-code/issues/3084
// OptionalSupportTestServiceNormalizeTopLevelJSONStringsForOneofs scans m's top level and, for keys that are members
// of any (or selected) oneof(s) in the given proto message type, it will parse string values
// that look like JSON and replace them with the parsed value.
// If oneofNames is empty, all oneofs are considered. Otherwise only the named oneofs are used.
func OptionalSupportTestServiceNormalizeTopLevelJSONStringsForOneofs(
	m map[string]interface{},
	msg proto.Message,
	oneofNames ...string,
) (changed bool) {
	if m == nil || msg == nil {
		return false
	}

	md := msg.ProtoReflect().Descriptor()
	// Build a set of target oneof descriptors
	var targetOneofs map[protoreflect.OneofDescriptor]struct{}
	if len(oneofNames) > 0 {
		targetOneofs = map[protoreflect.OneofDescriptor]struct{}{}
	outer:
		for i := 0; i < md.Oneofs().Len(); i++ {
			od := md.Oneofs().Get(i)
			for _, name := range oneofNames {
				if string(od.Name()) == name {
					targetOneofs[od] = struct{}{}
					continue outer
				}
			}
		}
	}

	// Collect JSON names of fields that belong to the target oneof(s)
	jsonNames := map[string]struct{}{}
	for i := 0; i < md.Fields().Len(); i++ {
		fd := md.Fields().Get(i)
		if fd.ContainingOneof() == nil {
			continue
		}
		if targetOneofs != nil {
			if _, ok := targetOneofs[fd.ContainingOneof()]; !ok {
				continue
			}
		}
		// fd.JSONName() is the canonical JSON field name ("cat", "dog", ...)
		jsonNames[fd.JSONName()] = struct{}{}
		// Also consider the proto field name in case your map uses snake_case
		jsonNames[string(fd.Name())] = struct{}{}
	}

	// Rewrite top-level stringified JSON for those keys
	for k, v := range m {
		if _, ok := jsonNames[k]; !ok {
			continue
		}
		s, ok := v.(string)
		if !ok {
			continue
		}
		trim := strings.TrimSpace(s)
		if trim == "" || !(strings.HasPrefix(trim, "{") || strings.HasPrefix(trim, "[")) {
			continue
		}
		var parsed any
		if err := json.Unmarshal([]byte(trim), &parsed); err != nil {
			continue // ignore if it's not valid JSON
		}
		m[k] = parsed
		changed = true
	}
	return changed
}

// OptionalSupportTestServiceTransformOneOfFields transforms discriminated union fields back to protobuf oneOf format
func OptionalSupportTestServiceTransformOneOfFields(m map[string]interface{}) {
	OptionalSupportTestServiceTransformOneOfFieldsRecursive(m)
}

// OptionalSupportTestServiceTransformOneOfFieldsRecursive recursively transforms oneOf fields in nested objects
func OptionalSupportTestServiceTransformOneOfFieldsRecursive(obj interface{}) {
	switch v := obj.(type) {
	case map[string]interface{}:
		// Transform oneOf fields in this object
		for key, value := range v {
			// Check if this looks like a oneOf discriminated union (must have OneOfType postfix)
			if strings.HasSuffix(key, "OneOfType") {
				if unionObj, ok := value.(map[string]interface{}); ok {
					if typeField, hasType := unionObj["object_type"]; hasType {
						if typeStr, ok := typeField.(string); ok {
							// Create a new object without the object_type field
							variantObj := make(map[string]interface{})
							for k, val := range unionObj {
								if k != "object_type" {
									variantObj[k] = val
								}
							}

							// Replace the union object with the variant object
							v[typeStr] = variantObj
							delete(v, key)
						}
					}
				}
			}
		}

		// Recursively process all values
		for _, value := range v {
			OptionalSupportTestServiceTransformOneOfFieldsRecursive(value)
		}
	case []interface{}:
		// Process array elements
		for _, item := range v {
			OptionalSupportTestServiceTransformOneOfFieldsRecursive(item)
		}
	}
}

// ForwardToOptionalSupportTestServiceClient registers a gRPC client, to forward MCP calls to it.
func ForwardToOptionalSupportTestServiceClient(s *mcpserver.MCPServer, client OptionalSupportTestServiceClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	TestOptionalFieldsToolDef := OptionalSupportTestService_TestOptionalFieldsTool

	// Convert simple Tool to mcp.Tool
	TestOptionalFieldsTool := mcp.Tool{
		Name:           TestOptionalFieldsToolDef.Name,
		Description:    TestOptionalFieldsToolDef.Description,
		RawInputSchema: json.RawMessage(TestOptionalFieldsToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		TestOptionalFieldsTool = runtime.AddExtraPropertiesToTool(TestOptionalFieldsTool, config.ExtraProperties)
	}

	s.AddTool(TestOptionalFieldsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.TestOptionalFieldsRequest

		message := request.GetArguments()

		// Transform oneOf discriminated unions back to protobuf format
		OptionalSupportTestServiceTransformOneOfFields(message)

		// Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
		// TODO: checking that the bug was fixed
		// _ = OptionalSupportTestServiceNormalizeTopLevelJSONStringsForOneofs(message, &req, "")

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.TestOptionalFields(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
