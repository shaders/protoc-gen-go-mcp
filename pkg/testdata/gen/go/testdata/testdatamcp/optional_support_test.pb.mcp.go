// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: testdata/optional_support_test.proto

package testdatamcp

import (
	testdata "github.com/shaders/protoc-gen-go-mcp/pkg/testdata/gen/go/testdata"
)

import (
	"context"
	"strings"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"encoding/json"
	"google.golang.org/protobuf/encoding/protojson"
	grpc "google.golang.org/grpc"
	"github.com/shaders/protoc-gen-go-mcp/pkg/runtime"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	OptionalSupportTestService_TestOptionalFieldsTool = runtime.Tool{Name: "testdata_OptionalSupportTestService_TestOptionalFields", Description: "Test method with various field types to test optional keyword support\n", JSONSchema: "{\"$schema\":\"https://json-schema.org/draft/2020-12/schema\",\"properties\":{\"annotated_required_field\":{\"description\":\"Field marked as required via annotation - should always be required\",\"type\":\"string\"},\"map_field\":{\"description\":\"Map field (should never be required as it can be empty)\",\"propertyNames\":{\"type\":\"string\"},\"type\":\"object\"},\"optional_annotated_field\":{\"description\":\"Optional field with annotation - annotation takes precedence\",\"type\":\"string\"},\"optional_bool\":{\"description\":\"Optional bool field\",\"type\":\"boolean\"},\"optional_field\":{\"description\":\"Optional field - should not be required regardless of setting\",\"type\":\"string\"},\"optional_number\":{\"description\":\"Optional int32 field\",\"type\":\"integer\"},\"regular_bool\":{\"description\":\"Regular bool field\",\"type\":\"boolean\"},\"regular_field\":{\"description\":\"Regular field - should be required when optional keyword support is enabled\",\"type\":\"string\"},\"regular_number\":{\"description\":\"Regular int32 field\",\"type\":\"integer\"},\"repeated_field\":{\"description\":\"Repeated field (should never be required as it can be empty)\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"annotated_required_field\",\"optional_annotated_field\"],\"type\":\"object\"}"}
)

// OptionalSupportTestServiceClient is compatible with the grpc-go client interface.
type OptionalSupportTestServiceClient interface {
	TestOptionalFields(ctx context.Context, req *testdata.TestOptionalFieldsRequest, opts ...grpc.CallOption) (*testdata.TestOptionalFieldsResponse, error)
}

// OptionalSupportTestServiceNormalizeTopLevelJSONStringsForOneofs scans m's top level and, for keys that end with
// "OneOfType" (as defined in the tool's JSON schema), it will parse string values that look like JSON
// and replace them with the parsed value.
func OptionalSupportTestServiceNormalizeTopLevelJSONStringsForOneofs(
	m map[string]interface{},
	toolSchema string,
) (changed bool) {
	if m == nil || toolSchema == "" {
		return false
	}

	// Parse the tool schema to find OneOfType fields
	var schema map[string]interface{}
	if err := json.Unmarshal([]byte(toolSchema), &schema); err != nil {
		return false
	}

	// Extract properties from the schema
	properties, ok := schema["properties"].(map[string]interface{})
	if !ok {
		return false
	}

	// Find all fields ending with "OneOfType"
	oneOfTypeFields := map[string]struct{}{}
	for fieldName := range properties {
		if strings.HasSuffix(fieldName, "OneOfType") {
			oneOfTypeFields[fieldName] = struct{}{}
		}
	}

	// Rewrite top-level stringified JSON for OneOfType fields
	for k, v := range m {
		if _, ok := oneOfTypeFields[k]; !ok {
			continue
		}
		s, ok := v.(string)
		if !ok {
			continue
		}
		trim := strings.TrimSpace(s)
		if trim == "" || !(strings.HasPrefix(trim, "{") || strings.HasPrefix(trim, "[")) {
			continue
		}
		var parsed any
		if err := json.Unmarshal([]byte(trim), &parsed); err != nil {
			continue // ignore if it's not valid JSON
		}
		m[k] = parsed
		changed = true
	}
	return changed
}

// OptionalSupportTestServiceTransformOneOfFields transforms discriminated union fields back to protobuf oneOf format
func OptionalSupportTestServiceTransformOneOfFields(m map[string]interface{}) {
	OptionalSupportTestServiceTransformOneOfFieldsRecursive(m)
}

// OptionalSupportTestServiceTransformOneOfFieldsRecursive recursively transforms oneOf fields in nested objects
func OptionalSupportTestServiceTransformOneOfFieldsRecursive(obj interface{}) {
	switch v := obj.(type) {
	case map[string]interface{}:
		// Transform oneOf fields in this object
		for key, value := range v {
			// Check if this looks like a oneOf discriminated union (must have OneOfType postfix)
			if strings.HasSuffix(key, "OneOfType") {
				if unionObj, ok := value.(map[string]interface{}); ok {
					if typeField, hasType := unionObj["object_type"]; hasType {
						if typeStr, ok := typeField.(string); ok {
							// First try to extract the field that matches the object_type
							// (for message types with $ref)
							if fieldValue, hasField := unionObj[typeStr]; hasField {
								// Move the field value directly to the parent level
								v[typeStr] = fieldValue
								delete(v, key)
							} else {
								// Fall back to old logic: create object without object_type field
								// (for primitive types or inline objects)
								variantObj := make(map[string]interface{})
								for k, val := range unionObj {
									if k != "object_type" {
										variantObj[k] = val
									}
								}
								// Replace the union object with the variant object
								v[typeStr] = variantObj
								delete(v, key)
							}
						}
					}
				}
			}
		}

		// Recursively process all values
		for _, value := range v {
			OptionalSupportTestServiceTransformOneOfFieldsRecursive(value)
		}
	case []interface{}:
		// Process array elements
		for _, item := range v {
			OptionalSupportTestServiceTransformOneOfFieldsRecursive(item)
		}
	}
}

// ForwardToOptionalSupportTestServiceClient registers a gRPC client, to forward MCP calls to it.
func ForwardToOptionalSupportTestServiceClient(s *mcpserver.MCPServer, client OptionalSupportTestServiceClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	TestOptionalFieldsToolDef := OptionalSupportTestService_TestOptionalFieldsTool

	// Convert simple Tool to mcp.Tool
	TestOptionalFieldsTool := mcp.Tool{
		Name:           TestOptionalFieldsToolDef.Name,
		Description:    TestOptionalFieldsToolDef.Description,
		RawInputSchema: json.RawMessage(TestOptionalFieldsToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		TestOptionalFieldsTool = runtime.AddExtraPropertiesToTool(TestOptionalFieldsTool, config.ExtraProperties)
	}

	s.AddTool(TestOptionalFieldsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.TestOptionalFieldsRequest

		message := request.GetArguments()

		// Fix oneof's passed as JSON string.
		_ = OptionalSupportTestServiceNormalizeTopLevelJSONStringsForOneofs(message, TestOptionalFieldsToolDef.JSONSchema)

		// Transform oneOf discriminated unions back to protobuf format
		OptionalSupportTestServiceTransformOneOfFields(message)

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.TestOptionalFields(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
