// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: google/bytestream/bytestream.proto

package bytestreammcp

import (
	bytestream "google.golang.org/genproto/googleapis/bytestream"
)

import (
	"context"
	"encoding/json"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"github.com/shaders/protoc-gen-go-mcp/pkg/runtime"
	grpc "google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"strings"
)

// Tool represents an MCP tool definition with essential fields
type Tool struct {
	Name        string
	Description string
	JSONSchema  string
}

var (
	ByteStream_QueryWriteStatusTool = Tool{Name: "google_bytestream_ByteStream_QueryWriteStatus", Description: "`QueryWriteStatus()` is used to find the `committed_size` for a resource\nthat is being written, which can then be used as the `write_offset` for\nthe next `Write()` call.\n\nIf the resource does not exist (i.e., the resource has been deleted, or the\nfirst `Write()` has not yet reached the service), this method returns the\nerror `NOT_FOUND`.\n\nThe client **may** call `QueryWriteStatus()` at any time to determine how\nmuch data has been processed for this resource. This is useful if the\nclient is buffering data and needs to know which data can be safely\nevicted. For any sequence of `QueryWriteStatus()` calls for a given\nresource name, the sequence of returned `committed_size` values will be\nnon-decreasing.\n", JSONSchema: "{\"properties\":{\"resource_name\":{\"description\":\"The name of the resource whose write status is being requested.\",\"type\":\"string\"}},\"required\":[],\"type\":\"object\"}"}
)

// ByteStreamClient is compatible with the grpc-go client interface.
type ByteStreamClient interface {
	QueryWriteStatus(ctx context.Context, req *bytestream.QueryWriteStatusRequest, opts ...grpc.CallOption) (*bytestream.QueryWriteStatusResponse, error)
}

// TODO: BUG: https://github.com/anthropics/claude-code/issues/3084
// ByteStreamNormalizeTopLevelJSONStringsForOneofs scans m's top level and, for keys that are members
// of any (or selected) oneof(s) in the given proto message type, it will parse string values
// that look like JSON and replace them with the parsed value.
// If oneofNames is empty, all oneofs are considered. Otherwise only the named oneofs are used.
func ByteStreamNormalizeTopLevelJSONStringsForOneofs(
	m map[string]interface{},
	msg proto.Message,
	oneofNames ...string,
) (changed bool) {
	if m == nil || msg == nil {
		return false
	}

	md := msg.ProtoReflect().Descriptor()
	// Build a set of target oneof descriptors
	var targetOneofs map[protoreflect.OneofDescriptor]struct{}
	if len(oneofNames) > 0 {
		targetOneofs = map[protoreflect.OneofDescriptor]struct{}{}
	outer:
		for i := 0; i < md.Oneofs().Len(); i++ {
			od := md.Oneofs().Get(i)
			for _, name := range oneofNames {
				if string(od.Name()) == name {
					targetOneofs[od] = struct{}{}
					continue outer
				}
			}
		}
	}

	// Collect JSON names of fields that belong to the target oneof(s)
	jsonNames := map[string]struct{}{}
	for i := 0; i < md.Fields().Len(); i++ {
		fd := md.Fields().Get(i)
		if fd.ContainingOneof() == nil {
			continue
		}
		if targetOneofs != nil {
			if _, ok := targetOneofs[fd.ContainingOneof()]; !ok {
				continue
			}
		}
		// fd.JSONName() is the canonical JSON field name ("cat", "dog", ...)
		jsonNames[fd.JSONName()] = struct{}{}
		// Also consider the proto field name in case your map uses snake_case
		jsonNames[string(fd.Name())] = struct{}{}
	}

	// Rewrite top-level stringified JSON for those keys
	for k, v := range m {
		if _, ok := jsonNames[k]; !ok {
			continue
		}
		s, ok := v.(string)
		if !ok {
			continue
		}
		trim := strings.TrimSpace(s)
		if trim == "" || !(strings.HasPrefix(trim, "{") || strings.HasPrefix(trim, "[")) {
			continue
		}
		var parsed any
		if err := json.Unmarshal([]byte(trim), &parsed); err != nil {
			continue // ignore if it's not valid JSON
		}
		m[k] = parsed
		changed = true
	}
	return changed
}

// ForwardToByteStreamClient registers a gRPC client, to forward MCP calls to it.
func ForwardToByteStreamClient(s *mcpserver.MCPServer, client ByteStreamClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	QueryWriteStatusToolDef := ByteStream_QueryWriteStatusTool

	// Convert simple Tool to mcp.Tool
	QueryWriteStatusTool := mcp.Tool{
		Name:           QueryWriteStatusToolDef.Name,
		Description:    QueryWriteStatusToolDef.Description,
		RawInputSchema: json.RawMessage(QueryWriteStatusToolDef.JSONSchema),
	}

	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		QueryWriteStatusTool = runtime.AddExtraPropertiesToTool(QueryWriteStatusTool, config.ExtraProperties)
	}

	s.AddTool(QueryWriteStatusTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req bytestream.QueryWriteStatusRequest

		message := request.GetArguments()

		// Limit to the "kind" oneof (optional). If you omit it, all oneofs are considered.
		_ = ByteStreamNormalizeTopLevelJSONStringsForOneofs(message, &req, "kind")

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.QueryWriteStatus(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
